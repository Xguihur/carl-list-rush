## 总结

1. 思路：
    1. 首先是要知道：交换两个节点，要有能够指向这两个节点的指针，这时候可以使用 cur指针 的方式，每次操作两个节点的时候，这个 cur 都指向他们前面一位！也可以不借助 cur 指针，就是边的操作顺序换一下就好了，先操作步骤三
    2. 其次是要知道退出循环的条件：当链表为奇数时，剩下最后一个节点不需要处理，这时候 cur.next.next = null,而当链表为 偶数 时，cur.next = null,
       所以满足以上任何一个就可以退出循环了！！！【注意：】为了防止空指针异常的问题，得先判断 cur.next != null,这和 js 的那种报错一样要注意
    3. 最后是如何交换的问题：如果按照顺序思维的话，就是分为三步：1. 将指向头节点的指针指向第二个节点，接着是第二个节点的下一个节点指向本来的第一个节点，然后将第一个节点的next指向第三个节点，最后将 cur
       指向第三个节点之前的节点（为了操作之后的两个节点）

2. Q&A
    1. 思考： 一开始陷入了思考，为什么最后 return dummyhead.next ，dummyhead.next 初始化是 head，我觉得一开始指向的节点已经被 cur
       移动到第二个节点了，最后难道不会少了第一个节点吗？不应该初始化为第二个节点吗？
        2. 解答：想了一下知道大概咋回事了，实际上cur 和 dummy 一开始指向的是同一个节点，cur 在第一次移动的时候就将 next 指向了 新的头节点，cur随着交换一直在变化，但是 dummy
           却还是虚拟头节点。最终只需要 return dummy.next 即可，因为这时候的 next 指针指向了新头节点。上面思考的情况是一开始就将头节点的值存了起来，最终return
           这个存起来的值，但是实际上最终是重新获取 next，然后return 的

## 学习算法的思路

1. 首先看github的介绍以及解题方法，看不太懂再去看视频（细节讲的很清楚）
2. 弄懂了就开始写代码：
    1. 先把思路以及要注意的细节在顶部捋清写下来
    2. 然后再写代码测试，多种方法尝试
    3. 最后看看有没有必要进行总结，技巧总结或者学习到新的设计思想的记录

## 这次写题的感悟

1. 通过周日大佬的帮助，java 写代码已经慢慢的规范化了，不仅是命名、调用方法，还包括创建类，以及方法和 leetcode 上给的尽量一致，刷起来好舒服！！！
2. 也明白了 psvm 的作用，一个包中一个入口函数，都通过这个入口函数进行代码执行！
3. 现在写算法的模式是：
    1. psvm 创建入口，并且继承 ListParent
    2. 在 main 中初始化链表
    3. 创建类，调用类的方法执行内部算法
    4. 打印结果
4. 写代码的过程中，遇到了输出结果有问题，不是我们想要的情况，我是**通过 debugger 的方式**，一步一步去看代码怎么样执行的，这样子特别快发现问题，一下子就知道是哪里的故障了！！！值得记录！！！
5. 在把循环的方法完成之后，通过对算法的理解，自己写了个递归，没看题解都写出来了，说明循环转递归也算是成功了！！！下面是步骤：
    1. 创建一个新的类，里面就执行循环的那个方法（本来想在一个类中实现两个方法的，但是后来发现需要返回虚拟头指针，需要一个全局变量，就新建一个比较好，不会互相污染了）
    2. 创建一个方法获取初始值以及首次调用递归方法
    3. 创建一个递归方法，设置好参数以及具体的逻辑代码
    4. 在递归方法内部设置好退出递归的条件以及继续递归的条件
    5. 这样就算是完成了 递归算法 的实现
    6. **总结：**
        1. 循环转递归，我认为最大的区别就是 循环 中每次处理的那个变量需要在代码体内进行重新赋值，而 递归 不需要手动的重新赋值，只需要控制下一次递归传入的参数是什么即可，循环内部只需要执行关键的逻辑代码
        2. 也就是说
            * 循环的方法：参数少但是代码内部需要对变量进行重新赋值
            * 递归的方法：参数多但是代码内部只需要处理核心代码，控制下一次递归函数的参数传入就好了
        3. 理解上来看 循环 的方法更符合人的思维，比较直观，递归可能比较深层次，但是一步步来也好理解