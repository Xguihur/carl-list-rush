## 总结

1. 思路：
    1. 首先是要知道：交换两个节点，要有能够指向这两个节点的指针，这时候可以使用 cur指针 的方式，每次操作两个节点的时候，这个 cur 都指向他们前面一位！也可以不借助 cur 指针，就是边的操作顺序换一下就好了，先操作步骤三
    2. 其次是要知道退出循环的条件：当链表为奇数时，剩下最后一个节点不需要处理，这时候 cur.next.next = null,而当链表为 偶数 时，cur.next = null,
       所以满足以上任何一个就可以退出循环了！！！【注意：】为了防止空指针异常的问题，得先判断 cur.next != null,这和 js 的那种报错一样要注意
    3. 最后是如何交换的问题：如果按照顺序思维的话，就是分为三步：1. 将指向头节点的指针指向第二个节点，接着是第二个节点的下一个节点指向本来的第一个节点，然后将第一个节点的next指向第三个节点，最后将 cur
       指向第三个节点之前的节点（为了操作之后的两个节点）

2. Q&A
    1. 思考： 一开始陷入了思考，为什么最后 return dummyhead.next ，dummyhead.next 初始化是 head，我觉得一开始指向的节点已经被 cur
       移动到第二个节点了，最后难道不会少了第一个节点吗？不应该初始化为第二个节点吗？
        2. 解答：想了一下知道大概咋回事了，实际上cur 和 dummy 一开始指向的是同一个节点，cur 在第一次移动的时候就将 next 指向了 新的头节点，cur随着交换一直在变化，但是 dummy
           却还是虚拟头节点。最终只需要 return dummy.next 即可，因为这时候的 next 指针指向了新头节点。上面思考的情况是一开始就将头节点的值存了起来，最终return
           这个存起来的值，但是实际上最终是重新获取 next，然后return 的

## 学习算法的思路

1. 首先看github的介绍以及解题方法，看不太懂再去看视频（细节讲的很清楚）
2. 弄懂了就开始写代码：
    1. 先把思路以及要注意的细节在顶部捋清写下来
    2. 然后再写代码测试，多种方法尝试
    3. 最后看看有没有必要进行总结，技巧总结或者学习到新的设计思想的记录

## 这次写题的感悟

1. 通过周日大佬的帮助，java 写代码已经慢慢的规范化了，不仅是命名、调用方法，还包括创建类，以及方法和 leetcode 上给的尽量一致，刷起来好舒服！！！
2. 也明白了 psvm 的作用，一个包中一个入口函数，都通过这个入口函数进行代码执行！
3. 现在写算法的模式是：
    1. psvm 创建入口，并且继承 ListParent
    2. 在 main 中初始化链表
    3. 创建类，调用类的方法执行内部算法
    4. 打印结果