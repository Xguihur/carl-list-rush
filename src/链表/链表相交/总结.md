## 总结

### 解题思路：

1. 我们不需要判断链表是否相交，直接去找交点，找到就返回，没有找到就表示不相交，这样就好了
2. 有一个很妙的点，自己没想到，但隐约有感觉的地方：两个链表要保证是一起到末尾的，也就是说如果链表不一样长，短的要先等一下长的，当两个链表等长了再一起前进，如果节点相同那就表示相交，如果到最后了都不相同那就直接返回null，特别关键
3. 所以我们要做的就是：
    1. 获取两个链表的长度
    2. 获取两个链表长度的 差值，并且能够知道哪个是长链表，哪个是短链表，先移动长链表
    3. 让长的链表先走 差值 步，最后进行一一比对就好

### 写代码遇到的细节：

1. 按照之前的方法去刷题效率高了起来，吸收得也很好，逻辑也清晰
2. 细节是在测试相交节点的时候，写的测试用例不够好
    1. 一开始是写了两个链表去执行函数，最后返回 null。然后我通过断点去看过程的时候发现本应该相等的地方，结果是不相等，最后返回为 null 了
    2. 于是我将代码对比了 题解，发现没什么不同，就提交到了Leetcode，发现能过，就知道用例有问题了
    3. 开始我还以为我弄不出这种用例，差点怀疑未来刷题的方法了。后来想了想，判断节点是否相同，实质就是判断地址，只需要我将第二个链表的其中一个节点指向第一个链表的任何一个节点，这时候链表就是相交的了
    4. 通过测试与修改确实也成功了，正确输出答案。所以问题出在用例这一块没搞好，Leetcode 的用例我也能做出了的

### 难点：

* 这次了Leetcode 的题目有点复杂，还有点看不懂，他给了这么多参数，还以为都要用上。但是最后看了题解，发现逻辑没这么复杂，甚至就是很简单的思路，Leetcode 上的那些参数啥的都没用上，这个读题能力看来也得训练一下了