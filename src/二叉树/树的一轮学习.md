# 算法

## 树

#### 树的递归遍历（递归三部曲）：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

#### 树的迭代遍历（借助栈）：

1. 先序遍历（中左右）
   1. 将根节点存入栈，接着从栈弹出，取当前值记录下来
   2. 判断当前节点的右节点是否存在，如果存在就存入栈中
   3. 接着判断当前节点的左节点是否存在，如果存在就存入栈中
   4. 从栈中弹出栈顶元素循环以上步骤，直到栈为空
2. 后序遍历（左右中）
   1. 因为一开始一定会访问根节点，于是使用技巧实现
   2. 对 先序遍历 的方式做一些小改变，实现 （中右左），最后再将数组翻转就得到了
   3. 在代码中的实现就是 先判断左节点，再判断右节点，最后翻转
3. 中序遍历（左中右）
   1. 这个较为之前两种不同，因为根在中间，所以思路需要转换，需要借助一个指针进行索引下一个节点。
   2. 首先将根节点存入栈中，指针记录根节点的左节点
   3. 其次判断指针是否位空，如果不为空则将指针节点存入栈中，指针继续指向左节点
   4. 接着遇到 空 的情况，从栈中弹出一个元素，将这个值存入最终输出的数组中。
   5. 同时将 指针 指向当前的值的右节点
   6. 此时循环 3-5 ，直到 栈 位空
4. 层次遍历
   1. 借助 队列 实现层次遍历，同时使用 queue size 记录当前层所有的节点数
   2. 首先将根节点存入队列，并且将队列的大小赋值给 size ，表示第一层拥有的节点数
   3. 接着 出队列一个节点，将该值输出，同时判断左右节点是否为空，不为空则入队列。
   4. 左右节点都处理完毕后，size--，如果 size 为0，此时重新初始化 size 为队列的大小表示新的一层
   5. 循环 3-4，直到队列为空则表示遍历完毕

#### 翻转二叉树

* 将树的左右节点翻转就好了，使用 迭代法 也行，使用 递归 也行，这里使用递归
* 那我们得确定用哪种递归的方法，前中后三种方式，中序需要特殊处理，前后都可以用，这里使用前序试试看

1. 三部曲：确定参数和返回值、确定终止条件、确定单次递归内容
2. 参数就是一个节点，返回值是根节点。终止条件是当前节点为 null 时终止。
3. 递归内容：
   1. 首先将根节点的左右子树交换
   2. 接着递归传入左子树，递归传入右子树
   3. 最终返回 根节点，就好了

> 后序遍历

1. 参数就是一个节点，返回值是根节点。终止条件也是当前节点为 null
2. 递归内容：
   1. 将根节点的右子树传入递归
   2. 将根节点的右子树传入递归
   3. 最后交换两个子树
3. 这种方式有一些像从叶子开始交换一样，先序遍历是从根开始交换

> 中序遍历

1. 参数就是一个节点，返回值是根节点。终止条件也是当前节点为 null
2. 递归内容：
   1. 将根节点的左子树传入递归
   2. 交换当前节点的左右子树
   3. 此时右边的节点为 null 或者完成交换，要交换的是左子树。于是将 当前节点的左子树继续传入递归
   4. 最后返回根节点就好

> 这三种方式区别就是 三行代码的顺序不同，或者说什么时候交换是关键，多加思考！

#### 对称二叉树

> 解题思路

1. 做这道题可以用递归也可以用迭代。关键是清楚怎么样去判断左右子树的节点是否相等，这很关键！
2. 实际上肉眼是能看出规律的，但是怎么转化成代码就需要转个弯，实际上也确实是这样做的
3. 找到几种不可能对称的情况，排除之后剩余就是对称的。当对称时如何做也是关键了！
4. 递归时的参数确定，左边的节点和右边的节点。返回值为 boolean。终止条件需要确定一下。递归体是外部递归一次，内部又递归一次，返回两次递归的交集！

> 后序遍历（只能用后续遍历，并且可以 左右中，也可以 右左中）

1. 确定参数和返回值：左节点，右节点；返回值为 boolean；
2. 确定终止条件：当只有一边有 null 时返回 false，当两边有值但不相等 返回 false，当两边都为 null 返回 true，最后是两边有值且相等的情况执行 inside 和 outside 递归，最后返回俩的交集！

> 迭代法（开始使用层次遍历的 队列，后来发现不过是每次弹出两个进行对比，只要不符合条件就返回 false，这时不涉及顺序，无论是 队列、栈还是数组都可以实现）

1. 使用一个队列（容器就行）存放元素，一开始将根节点的左右子节点传入队列
2. 接着从队列中取两个节点，比较这两个节点是否相等或者是否都为空，如果不是直接返回 false
3. 如果是则将 1->left 和 2->right 传入队列，再将 1->right 和 2->left 传入队列
4. 循环以上2-3，直到队列为空。最后返回 true

#### 二叉树的最大深度

> 解题思路：

1. 先分清两个概念：深度和高度 -- 深度是像水一样从上到下，如根节点到当前节点的节点数或边的数量；高度是像树一样从下到上，如当前节点到根节点的节点数或边的数量
2. 递归解题可以使用深度也可以使用高度，只是使用深度来说会比较好实现一些也比较符合逻辑，就像忍者神龟打冠军杯一样两两获胜的进行竞争，一路晋级！
3. 也可以使用层次遍历的方式实现，使用 队列 进行遍历，用一个变量记录当前层就好了

> 高度递归法（实际上就是 后序遍历，左右中）

1. 确定参数和返回值：传入一个节点，返回值是 当前节点的高度+1
2. 确定终止条件：当节点为 null 时，return 0
3. 确定单次递归：将 左子节点传入递归、将 右子节点传入递归，最后返回 1+max(左递归的返回值，右递归的返回值)
4. 最后返回的值就是根节点的最大深度

> 深度递归法（实际上就是 前序遍历， 中左右）

解题思路：

* 首先全局定义一个变量存放 高度，未来可以做比较累加
* 接着实际上就是遍历每一个节点，并且将他们的高度和那个全局变量比较，保留大的
* 最终返回这个 全局变量 即可

解题过程：

1. 确定参数和返回值：传入一个节点，以及当前层的 高度 +1，没有返回值，终止即可
2. 确定终止条件：当节点为 null 时，return ； 比对完 全局变量 和 当前高度，取最大的，完事就 return 就好了
3. 确定单次递归：
   1. 首先判断当前节点是否为 null，如果不是则比对 全局变量 取最大的赋值
   2. 将 左子节点和 当前高度+1 传入递归、将 右子节点和当前高度 +1 传入递归
   3. 接着 return
4. 递归最终出来之后将 全局变量 作为返回值即可

> 层次遍历（使用队列，另外加一个 level 记录第几层就好（略）

#### n叉树的最大深度

1. 会了 二叉树 的方法，n叉树也一样会了，只是它内部不再有 left、right，而是只用一个 children指针，值为数组，内部有多个节点
2. 递归时 通过 for 循环 遍历 children 数组做处理就好
3. 迭代时 也是通过 for 循环遍历数组，将值存入队列就好

#### 二叉树最小深度

解题思路：

* 这个和最大深度的方法类似，只是有一个特殊情况需要处理
* 找最小深度时，要找的是从 **根节点** 到最近的 **叶子节点** 的距离
  * 这里的细节的具体实现是很难想到的，一个很巧妙的：实际上模拟一下现实中走向就能找到以下规律，需要脑子再多转一点！！！
  * 如果左节点为空，右节点不为空，就取右节点的深度作为最小深度
  * 反之亦然
  * 如果都为空或者都不为空，就取两边的最小深度
* 根节点如果只有一边有节点，另外一边为空的情况容易出错，要记得 第二点 的细节

解题过程：

> 递归遍历（高度--后序遍历）

1. 确定参数和返回值：传入一个节点，返回值是 当前节点的高度+1
2. 确定终止条件：当节点为 null 时，return 0
3. 确定单次递归：
   1. 这里是最关键的，也是和 最大深度 不同的地方
   2. 首先将 左节点 传入递归，其次将 右节点 传入递归
   3. 接着判断：
      1. 如果左节点为空，右节点不为空，则 return 1+右节点递归的返回值
      2. 如果右节点为空，左节点不为空，则 return 1+左节点递归的返回值
      3. 否则就是两者都为空或都不为空的情况，return 1+min（左节点递归返回值，右节点递归返回值）
4. 最后返回的值就是根节点的最小深度

> 递归遍历（深度--先序遍历）



> 层次遍历 

#### 完全二叉树的节点个数

解题思路：

1. 和求最大高度差不多，可以遍历全部节点并且收集左右子树的节点数向上传递
2. 也可以求最大深度，并且每遍历一个节点，总值累加一即可
3. 也可以使用层序遍历，即迭代法求所有的节点个数
4. 也可以利用 完全二叉树 的特性，将它拆分成多个 满二叉树，将每一个满二叉树的节点值用公式记录下来，最后拿到所有的节点

> 后序遍历（求高度）

1. 确定参数和返回值：参数为一个节点作为根节点，返回值为这个节点下所有的节点数，即为 number 类型
2. 确定终止条件：终止条件是当这个节点为 null 的情况，返回 0
3. 确定单次递归的逻辑：
   1. 如果节点为 null 则返回 0
   2. 将左子树传如递归
   3. 将右子树传入递归
   4. 最后将两个递归的返回值 加起来再+1，返回出去

> 层次遍历



> 满二叉树遍历



#### 判断是否为平衡二叉树

> 后序遍历



#### 二叉树的所有路径

> 涉及到回溯，并且输出的结构与之前有一些不一样，是一个分水岭题目，值得一做！有难度！

解题思路：

> 先序遍历



> 层次遍历