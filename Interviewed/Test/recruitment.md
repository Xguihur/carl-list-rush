
## 数字马力笔试（2023-10-09）

> 笔试总结

1. 笔试中考察的三个点扣了分
   1. 正则表达式
   2. JS 的进制转换
   3. 函数柯里化
2. 正则表达式的补充
   1. 直接使用 字符串 的原型方法 **replace(/[要替换的元素],"[用什么来替换]")**  中括号表示占位，提示传啥的
3. JS 的进制转换，查了资料学会了一下方法

```javascript
---------十进制转 n 进制-----------
使用 Number 的 toString 方法可以实现，如：
    Number(255).toString(16) // #ffffff
	Number(10).toString(2) // 1010

---------底进制转高进制(这个没太明白，只是二进制转8、10、16可以，其他都没成功过，还不太会)------------
Number.parseInt（string,radix）,这个是把字符串(只能由字母和数字组成)，这个只能是由低进制转高进制，如二进制转八进制，但是八进制不能转二进制，radix表示进制，取值2~36。
	 Number.parseInt(0110, 16) // 272
	

```

4. 函数柯里化（暂时不花时间先，不感兴趣，纯算法，刷完随想录再说）



## 北京 MetaApp 实习

> 题目 

**这个题目很恶心，有三大题，每大题还有三小题，每小题都是新的一个题型，也就是说 9 道算法题，一开始都不想做了，后面多亏了小涛，才发现后面有题是重复的**

> 第一题

1. 第一题是一个数组，下标是 i ，值是 arr[i] ，下标是宽度，arr[i] 是高度，求这个任意两个点以及 x 轴、x 轴平移线 构成图形的最大面积
   1. 一开始没啥头绪，小涛给了方法是 使用头尾双指针，头尾取高度最低的，以及 两点间的宽度 相乘求出面积，然后比大小存起来，直到 left > right

1. 第一题第二个小问是给出一个数，求出这个数的阶乘。然后对这个阶乘求 约数 ，存到数组中，取前五个 约数或者不足五个的取全部。
   1. 这题不是很难，就按步骤去操作就好。先求 阶乘 ，注意负数的情况取绝对值就好
      1. 从 1 开始循环相乘，一直到 n 拿到这个数
   2. 然后对这个阶乘求约数，从 1 开始遍历，一直到 n，将能整除的都存到数组中
   3. 最后取数组前五个或者不足五个的情况全部取出来。使用 **arr.splice(0,5)** 取出来
2. 第一题第三小问不难，解题方法不走弯路就很快写出来，但是我一开始思维还是走弯路了。
   1. 题目是说：输入一个数组A，然后需要输出一个数组B。这个数组B的每一项的值，是在A中除去对应下标外的所有值相加再平方
   2. 解题：
      1. 自己还想着遍历 A ，用两个 for 循环，每次相加所有值，判断如果下标相等就跳过
      2. 但是题解的方法是求出所有值的和：total，然后遍历数组，每次用 这个和 total 减去 当前下标的值，再平方就得到了 B 中对应的下标
      3. 这个方法太妙了，想到就不用走太多弯路浪费时间了

> 第二题

1. 第一小问是给一个数组，让我们对它进行排序，排序后在数组中 查找 83，如果找到了就返回它的索引，如果找不到就按顺序插入 83 后返回它的索引

   1. 这题思路不难，就是按顺序先把一个数组进行排序，排序后查找 83 的位置，找到了就返回，找不到就返回应该在的位置的索引就好
      1. 这个排序是一个细节，有点忘记了还写错了，写法是：`arr.sort((a,b)=>a-b)`
      2. 接着是查找，小涛给的方法是使用二分法，找到就返回，找不到就返回 left ，因为那个时候的 left 已经是理论上 83 应该在的位置了
      3. 我自己的方法是使用正向遍历，找到就返回索引，一旦第一次大于83了，就返回这个索引，因为这个位置就是放 83 的
         1. 我一开始也想到了 二分法，但是没有使用的原因是怕有多个 83 的时候取到的不是最先出现的。但是后来想想这都是排好序了的，找到的时候83都在一起，或许这种情况下一定是拿到前面的吧**（还是不太确定，但是能知道是在一块了）**
         2. 而且还没有读清题目，直接返回索引就可以了的，我还去移动数组，用两个for 循环去遍历移动，太浪费时间了！
   2. 第二小问是进制转换，输入一个数，取它的绝对值，然后求他的 8进制 数，用数组表示
      1. 这个也是按步骤，但是难点在于 进制转换，10 -- > 8 
      2. 先使用 `Math.abs(n)` 取绝对值，接着使用 **除基取余** 法以及 **数组的头插法** 完成此题
         1. 先判断 n 是不是0，如果是就返回一个 [0] 
         2. 接着定义一个数组，接着循环 while(n>0) 把 n % 8 用 **unshift** 存入数组中，接着 n / 8 重置一下 n
         3. 最后返回这个数组
      3. 这个方法值得借鉴，进制转换的
   3. 第三小问也不难，是考察操作的。
      1. 题目是给一个数组，入栈这个数组的前五个元素，如果不足五个就全部入栈；接着再出栈两个元素，不足两个就全部出栈。最后将栈中剩下的元素翻转输出
      2. 解题：
         1. 拿到这题感觉就是简单题，但是还是蛮多细节不知道怎么处理的，看过小涛的方法后，对于现阶段的提升是很大的，虽然还是简单操作但就是这些简单操作会浪费很多时间
         2. 首先是入栈操作，怎么样只入栈五个或者不足五个的情况呢？
            1. `Math.min(5,arr.length)` 使用 for 循环，终止条件取这个 Math 的值即可，最终就能正常得到第一轮数组了啊
         3. 接下来是出栈，出栈 两个 或者 全部出栈 的方法还是用以上的方法即可
         4. 最终是翻转输出，一开始还想着一一出栈到新的数组中，但可以直接使用数组的翻转方法 reverse() 

   > 第三题

   1. 第一题也比较有意思，解这题不难，但是如果输入 的不是规定的数组，而是会变化的话，小涛给的这种方法非常值得学习，递归！
      1. 题目：
         1. 输入一个数 n ，当n小于1时取1，大于1000时取1000 。 然后有五个人，第五个人比第四个人多7颗糖果，以此类推，第一个人有 n 颗糖果，求 第五个人的糖果数量
      2. 思路：
         1. 因为这题固定是 5 个人，所以不用算法都能算出来是 n+（4*7） ，但是如果 不是固定 第5个人，那就难了
         2. 小涛的算法是：
            1. 首先看 n 的界限，确定好 n 来
            2. 接着创建一个递归函数，第一个参数是 第几个人，第二个参数是 当前糖果数。
               1. 函数内部判断 人 是不是 1 ，如果是就返回 当前的糖果数作为最终结果（因为已经经过了前面几轮的累加）
               2. 如果不是就继续递归，人数-1，糖果+7
         3. 这个算法非常妙，递归方法值得学习，思路也是很巧妙，虽然很简单
   2. 第二题和之前的 八进制转化一样，不过这题是转成 七进制，关键就是学会 **除基取余法** 这个核心方法
   3. 第三题和之前的排序后找特定值索引是一模一样，只是数字不同而已，我这里用了 二分法！

> 总结

1. 题目很多，但也都不难。但是即使是不难，在有限的时间内我也做不完，首先思路比较难想，其次是很多细节都会花很多时间，一些操作不熟练，例如 翻转、循环取最小的作为目标、递归取糖果等，这些都是没见过的，现在见过后下次就熟练了，所以还得是多练才行！
2. 题目总和：
   1. 类似二维数组求面积最大值，用 双向指针。
      1. 难点是题目的理解上比较难，懂了题目问什么、懂了解题要注意的细节后就不难了
   2. 求阶乘再求约数
      1. 难点是每一步之前都会浪费很多时间
      2. 最后取值的时候也不会取，可以用之前的 Math 的方法，也可以用 slice 取 5 个元素的数组
   3. 给一个数组，返回一个新数组，新数组的下标对应的值为 初始数组 中 非该下标 的所有元素的和 再 平方
      1. 难点是自己可能绕弯路用两个for循环解题，但实际上可以很简单，先求出 和 再遍历计算就好了
   4. 给一个数组排序后查找某个值的索引，不存在就返回一个它应该在的位置的索引
      1. 难点按顺序操作时的每一步都不太熟练浪费很多时间
      2. 排序、查找、返回值，这些细节都会花费时间。
      3. 再加上没有认真读题，还去重新移动了后续数组浪费时间了
   5. 将一个十进制数转化为 八进制
      1. 难点首先是对 Math 方法的使用，取绝对值一开始用的还不够自信，还有 max、min 这些方法
      2. 其次就是 进制转换 的核心之前没有学会，现在倒是知道了，使用代码贯彻 除基取余法
   6. 将一个数组入栈前五个，不足五个全入栈，再出栈顶部两个元素，不足则全部出栈，最后翻转栈中元素返回栈
      1. 难点首先是细节的处理，不足五个的情况，之前肯定是会花很多时间的，现在学到了下次遇到就会了
      2. 接着就是一些方法的使用，例如 reverse 翻转，还不太会用，只想着手动实现
   7. 递归求糖果的题目，这个递归算法很妙
      1. 难点是一开始想到递归就不想做，也难以在有限的时间沉下来思考这道题怎么写，题都都不明白
      2. 找到规律后就能很好的写这道题了，依赖于一开始的答案的，这就是 dp ，但是不复杂，倒像数学题一样