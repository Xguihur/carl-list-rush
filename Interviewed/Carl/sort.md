
## 快速排序

### LeetCode 题目：暂无

`使用快速排序将一个数组变成有序数组`

**快速排序的原理就是通过递归，让每次递归的结果都保证 Pivot 大于等于左边所有的数， Pivot 小于等于右边所有的数，最终实现将数组变成有序数组** 

> 解题思路

1. 选取当前数组的第一个元素作为 Pivot。接下来就是第一次的排序
2. 设置 left 和 right，从右边的指针开始处理。
3. 循环判断右边的值。如果 右边的值大于等于 Pivot，那就不需要动这个元素，right 的 指针 自减，继续循环判断，直到右边的值 小于 Pivot 的值或 left >= right 时结束 循环。
4. 接着判断当前 left 是否小于 right，如果是，就表示此时 right 指向的值小于 Pivit。将 right 指向的值赋值给 left。
5. 此时循环判断左边的值。如果 左边的值 小于等于 Pivot，那就不需要动这个元素，left 的指针 自增，继续循环判断。直到 左边的值大于 Pivot 或 left >= right 时结束 循环。
6. 接着判断 left 是否小于 right ，如果是，就表示此时的 left 指向的值大于 Pivot。将 left 指向的值赋值给 right。
7. 接着判断left 是否 = right，如果是，就表示此次循环结束，将 Pivot 插入 他们指向的位置。
8. 在外部，对左右两个数组都进行一次 递归！即传入新的数组，重置 left 和 right即可。

**细节** ：

1. 函数的参数由三部分构成：一个数组、left、right。
2.  left 和 right 与 Pivot 作比较时，小于等于 或者是 大于等于的情况，相对应 left 和 right 他们都不需要多此一举移动元素，保持不动即可！
3. 在完成交换后，不需要对指针进行相关移动操作。这会在后面的判断中处理。
4. 在函数一进来时，判断 left 是否 大于等于 right ，如果是则表示这个已经处理过了，或者是 只有一个元素！就直接 return，用于结束递归！非常妙，直接解决了判断数组长度的问题。

```javascript
const arrs = [4,1,3,28,9,17,14,19,22,8]
// 左闭右闭
const quickSort = (arr,left,right) => {
    let l = left
    let r = right
    if(l >= r){
        return
    }
    
    const pivot = arr[l]
    while(l < r){
        // 只有 l = r 或者 arr[r] 的值小于 pivot 时才结束循环
        while(l < r && arr[r] >= pivot){
            r--
        }
        if(l < r){
            // 这个判断表示该将右侧的值插入到左侧的坑了
            arr[l] = arr[r]
        }
        while(l < r && arr[l] <= pivot){
            // 只有 l = r 或者 arr[r] 的值大于 pivot 时才结束循环
            l++
        }
        if(l < r){
            // 这个判断表示该将左侧的值插入到右侧的坑了。
            // 此时右侧的指针虽然指向是有值的，但是那个值可以被覆盖，相当于是一个坑了！
            arr[r] = arr[l]
        }
        if(l == r){
            arr[l] = pivot
            // 当指向了这行代码时，表示这一轮的排序完毕，Pivot 左右两侧的值都符合规则
        }
    }
    // 递归指向函数，将 Pivot 左侧的数组和 Pivot 右侧的数组继续排序
    quickSort(arr,left,l-1) // Pivot 左侧的部分进行递归
    quickSort(arr,l+1,right) // Pivot 右侧的部分进行递归
}

// 执行查看结果
quickSort(arrs,0,arrs.length-1)
console.log(arrs)
```



> 总结：

* 我目前使用的就是挖坑法来实现，网上看到有说用交换法的。现在还不打算去了解，如果面试问到了再现场思考好了，学会挖坑法能做出题目就OK了
* 整体流程还算比较好理解
  * 函数一开始先判断 left 和 right 是否合规，是用于结束递归的判断
  * 接着进行循环，目的是要把当前的数组分成以 Pivot 为中心的两部分。循环的核心代码分为五部分：
    * 此时坑在左侧。循环判断右指针的值，只有小于 Pivot 的才要填入坑中，否则一直向左移动指针，直到等于 left
    * 退出以上循环有两种可能，接着只要 left < right 就表示需要填坑，将右侧的值填入坑中
    * 此时坑在右侧。循环判断左指针的值，只有大于 Pivot 的才填入坑中，否则一直向右移动指针，直到 等于 right
    * 退出以上循环有两种可能，接着只要 left < right 就表示需要填坑，将左侧的值填入坑中
    * 最后判断 left 和 right 是否相等，如果值是相等的就表示这次的数组已经分为了两部分，将 pivot 填入坑中即可
  * 到这里数组就被分为两部分了，对这两部分进行递归，最终就能得到排好序的数组了


---