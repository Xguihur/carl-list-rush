# 基础问题

## 斐波那契数列

### [LeetCode 题目](https://leetcode.cn/problems/fibonacci-number/)

`斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。` 

**动态规划五部曲**

1. 确定 `dp` 数组以及下标的含义（通常用于确定循环时的边界确认，蛮重要的）
2. 确定递推公式
3. `dp` 数组如何初始化
4. 确定遍历顺序（从前往后还是从后往前）
5. 举例推导 `dp` 数组（取一个值进行推演数列，用于验证结果 debug）

**三种方法**

1. 根据 五部曲 的思想编码，一步一步得到结果，同时也得到一个完整的数组
2. 优化以上的思想，不需要记录遍历过的结果，只需要最终的答案即可。交换两个元素即可
3. 使用 递归 的方式 实现本题（暂时还没用上 递归 三部曲，还是硬写的）

> 解题思路

**原始方法(ts:O(n,1))**

1. 根据五部曲，得到从前往后的顺序，结合递推公式，进行初始化元素
2. 使用 for 循环 进行递推公式遍历，直到找到目标元素
3. 返回目标元素
4. 举例数组（0，1，1，2，3，5，8，13，21，34，55）

```javascript
var fib = function(n) {
    if(n<2) return n
	let dp = [0,1]
    for(let i=2;i<=n;i++){
        dp[i] = dp[i-1]+dp[i-2]
    }
    return dp[dp.length-1]
};
```

**优化方法(ts:O(n,1))**

1. 不需要使用一个数组记录已经遍历过的元素，用两个值记录前一个和前两个即可，然后一直交换
2. 交换涉及到临时变量

```javascript
var fib = function(n){
    if(n<2) return n
    let pre0 = 0
    let pre1 = 1
    let temp 
    for(let i=2;i<=n;i++){
        temp = pre0+pre1
        pre0 = pre1
        pre1 = temp
    }
    return pre1
}
```

**递归方式(ts:O(n^2,n)**

1. 递归三部曲：
   1. 确定递归参数和返回值：参数是 n ，返回值 是 dp 的值，即 前两个相加 或 0，1
   2. 确定退出递归条件：n 为 0或1 的情况，将值返回
   3. 确定循环体代码：判断是否为 0、1，否则 返回 前两者的 dp 值的和
2. 有了递推公式后，写递归也十分清晰了不少

```javascript
var fib = function(n){
    if(n<2) return n
    return fib(n-1)+fib(n-2)
}
```

---

> 总结

1. 五部曲的作用在实践后知道了用意是什么
   1. 比如第一步确定 下标 实际意义是在循环的时候确定边界条件
   2. 递推公式和初始化不用说了，遍历顺序是决定了用什么思想去写代码
   3. 最后的举例也是让自己编码的的时候也更好的整理思路和debug时验证
2. 写的时候还是有些粗心，初始化、边界条件、起始循环位置、返回值 都有些差错，得注意一下



## 爬楼梯

### [LeetCode 题目](https://leetcode.cn/problems/climbing-stairs/)

`假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。`

**发现规律后就知道，这实际上就是斐波那契数列！**

1. 推演一下几个例子找到规律，n=1，n=2，n=3 的时候有几个答案
   1. 规律为 ，第 n 个台阶可以被 n = n-1 时的方法数得出，也能有 n=n-2 时的方法数 得出
2. 接下来就 动态规划 五部曲
   1. dp[i]的含义 : 第 i 个台阶有 dp[i] 种方法爬到
   2. 找到递推公式：dp[i] = dp[i-1] + dp[i-2]
   3. 初始化：dp[0] =0,dp[1] = 1,dp[2] = 2
   4. 遍历顺序：从前往后
   5. 列举一些例子：0,1,2,3,5,8,13,21

> 解题思路

**实际上就是斐波那契数列，只是 dp[0] 可以不考虑罢了，或者说为0，于是只用正常思维的方法解题，其余不去重复**

1. 初始化两个变量用于交换，还有一个临时变量
2. 确定好 i 的值后，进行 for 循环遍历
3. 在循环内部不断交换获取新值即可

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n<3) return n//剪枝一下，n = 1，2 时，值也为 1，2 。 实际上 n = 3 也能剪枝的，但为了题目的题意合理性，就不做这样的剪枝，保持解题思路的清晰即可
	let pre1 = 1
    let pre2 = 2
    let temp
    for(let i=3;i<=n;i++){
        temp = pre1+pre2
        pre1 = pre2
        pre2 = temp
    }
    return pre2
    
};

```

> 总结

1. 发现做这个题目，掌握了 递推公式 找到规律后会非常方便，解题也更容易发现本质！一开始看着很难，但实际上和斐波那契就是一样的，做数学题一样
2. 掌握了 dp 五部曲确实对于解题非常高效，继续练习
3. 适当的剪枝取舍是需要技巧的，这点在做完题目熟悉了后不断优化即可



## 使用最小花费爬楼梯

### [LeetCode 题目](https://leetcode.cn/problems/min-cost-climbing-stairs/)

`给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。`

`你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。`

**题意分析**

1. 可以从 0 或 1 的下标开始往上爬，并且需要支付当前位置上的 体力花费，每次可以选择爬 一层 或者 两层
2. 求爬到第 n 层 的最低体力花费，到达 第 n 层 有两种体力花费，取两者最小值即可：
   1.  到达 n-1 层的体力花费+支付他那层的花费到达 n 层
   2.  到达 n-2 层的体力花费+支付他那层的花费到达 n 层
3. 有一个 cost 数组表示体力花费了，但是做 dp 题还需要一个 dp 数组存储遍历后的结果，所以写的时候要弄一个 dp 数组，并且表示 dp[i] 的意思

> 解题思路

1. dp 五部曲

   1. 建立 dp 数组，并且确立 dp[i] 的含义：到达第 i 层楼梯所花费的体力
   2. 递推公式：dp[i] = min(dp[i-1]+cost[i-1] , dp[i-2]+cost[i-2])
   3. 确定初始化参数：dp[0] = 0,dp[1 ] = 0 ,表示到达 第0层和第1层不需要花费体力
   4. 确定遍历顺序：很明显dp[i] 是依赖于 前两个 楼层花费的体力值总和得到的最小值，所以 从前往后 遍历即可
   5. 举例推导 dp 数组：
      1. 假设 cost 数组为：[1,100,1,1,1,100,1,1,100,1]
      2. 那么推导得到的 dp 数组为：[0,0,1,2,3,4,5,6] ，即 到达顶层需要 dp[6] = 6 个体力值为最优
   6. 这五部曲很多细节都包括在里面了，能避免走很多弯路，慢慢学习

   ```javascript
   /**
    * @param {number[]} cost
    * @return {number}
    */
   var minCostClimbingStairs = function(cost) {
   	const dp = [0,0]
       for(let i=2;i<=cost.length;i++){// 这个 i 的含义需要理解一下，是 cost 数组的下标,注意循环条件是 小于等于 
           dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
       }
       return dp[cost.length-1]
   };
   const min = function(a,b){
       if(a>b){
           return b
       }else{
           return a
       }
   }
   
   ```

   > 总结

   1. 写的时候在循环时 的 i 又有点忘记了含义，得想想才知道是对应 cost 的数组，做题过程得清晰知道 dp 数组表示的是什么意思，不然容易蒙了！！！知道后就不会太乱，能正常写出逻辑
   2. 循环的退出条件没有掌握好，要到 楼梯顶层，也就是跳出数组，边界要搞好，得思考一下
   3. 五部曲还不太熟，慢慢锻炼，每一次写都有新的感受

